<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NerdMiner Dashboard</title>
  <style>
    :root{
      --bg:#0b1220;--card:#111b2e;--text:#e9eefc;--muted:#a9b3cf;
      --ok:#39d98a;--bad:#ff5c5c;--warn:#ffcc00;
      --btn:#1b2a47;--pill:rgba(255,255,255,.06);
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
    .wrap{max-width:1020px;margin:0 auto;padding:18px}
    h1{font-size:24px;margin:0 0 8px}
    .sub{color:var(--muted);font-size:13px;margin-bottom:14px;word-break:break-all}
    .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px}
    @media(min-width:860px){.grid{grid-template-columns:repeat(4,minmax(0,1fr))}}
    .card{background:var(--card);border-radius:16px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
    .k{color:var(--muted);font-size:12px}
    .v{font-size:20px;font-weight:750;margin-top:6px;word-break:break-word}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .pill{display:inline-flex;gap:8px;align-items:center;background:var(--pill);border-radius:999px;padding:7px 10px;font-size:13px}
    .dot{width:10px;height:10px;border-radius:50%}
    .ok{background:var(--ok)} .bad{background:var(--bad)} .warn{background:var(--warn)}
    .small{font-size:12px;color:var(--muted)}
    button{background:var(--btn);color:var(--text);border:0;border-radius:12px;padding:10px 12px;font-weight:600;cursor:pointer}
    button:active{transform:translateY(1px)}
    code{background:rgba(255,255,255,.08);padding:2px 6px;border-radius:8px}
    .footer{margin-top:14px;color:var(--muted);font-size:12px;line-height:1.4}
    .list{display:flex;flex-direction:column;gap:10px;margin-top:10px}
    .item{background:rgba(255,255,255,.04);border-radius:14px;padding:12px}
    .item .title{font-weight:750}
    .cols{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;margin-top:8px}
    @media(min-width:860px){.cols{grid-template-columns:repeat(4,minmax(0,1fr))}}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>NerdMiner Dashboard</h1>
    <div class="sub">Wallet: <code id="wallet"></code></div>

    <div class="row">
      <div class="pill"><span class="dot" id="dot"></span><span id="status">Carregando…</span></div>
      <div class="pill">Atualiza: <span id="tick">—</span>s</div>
      <button id="refresh">Atualizar agora</button>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="card"><div class="k">Hashrate</div><div class="v" id="hashrate">—</div></div>
      <div class="card"><div class="k">Last seen</div><div class="v" id="lastseen">—</div></div>
      <div class="card"><div class="k">Best difficulty</div><div class="v" id="bestdiff">—</div></div>
      <div class="card"><div class="k">Uptime (sessão)</div><div class="v" id="uptime">—</div></div>
    </div>

    <div class="card" style="margin-top:12px">
      <div class="k">Workers / Sessões</div>
      <div id="workersWrap" class="list"></div>
      <div class="footer">
        Dica: se “Last seen” começar a subir (ex: 2 min ago), seu ESP32 caiu ou perdeu Wi-Fi.
      </div>
    </div>
  </div>

<script>
  // === CONFIG ===
  const WALLET = "bc1q26ewxzrujkhz8tyazxtxdlcu4amduam6xgl78v";

  // API direta do Public Pool (foi a que você capturou no Network)
  const DIRECT_API = `https://public-pool.io:40557/api/client/${WALLET}`;

  // Se um dia precisar de proxy (CORS), troque por algo assim:
  // const API = `https://SEU-DOMINIO.com/pproxy.php?wallet=${encodeURIComponent(WALLET)}`;
  const API = DIRECT_API;

  document.getElementById("wallet").textContent = WALLET;

  const els = {
    dot: document.getElementById("dot"),
    status: document.getElementById("status"),
    tick: document.getElementById("tick"),
    hashrate: document.getElementById("hashrate"),
    lastseen: document.getElementById("lastseen"),
    bestdiff: document.getElementById("bestdiff"),
    uptime: document.getElementById("uptime"),
    workersWrap: document.getElementById("workersWrap"),
  };

  function setStatus(kind, text){
    els.dot.className = "dot " + kind;
    els.status.textContent = text;
  }

  function fmtNum(n){
    if (n === null || n === undefined) return "—";
    const x = Number(n);
    if (Number.isNaN(x)) return String(n);
    return x.toLocaleString("pt-BR");
  }

  function pick(obj, keys){
    for (const k of keys){
      if (obj && obj[k] !== undefined && obj[k] !== null) return obj[k];
    }
    return undefined;
  }

  function looksOnlineFromLastSeen(lastSeen){
    if (!lastSeen) return false;
    const s = String(lastSeen).toLowerCase();
    return s.includes("just now") || s.includes("agora") || s.includes("sec") || s.includes("seg");
  }

  // Converte um possível objeto worker (campos variam) em algo exibível
  function normalizeWorker(id, w){
    const hashrate = pick(w, ["hashrate","hashRate","khs","kh_s","hashrate_khs"]);
    const shares   = pick(w, ["shares","validShares","completedShares","acceptedShares","shares32","shares_32"]);
    const uptime   = pick(w, ["uptime","uptimeHuman","timeMining","time_mining","sessionUptime"]);
    const lastSeen = pick(w, ["lastSeen","last_seen","lastSeenHuman","last_seen_human","seen","last"]);

    return { id, hashrate, shares, uptime, lastSeen, raw:w };
  }

  function renderWorkers(data){
    els.workersWrap.innerHTML = "";

    // Alguns formatos possíveis:
    // 1) data.workers = { "sessionId": { ... }, ... }
    // 2) data.workers = [ { ... }, ... ]
    // 3) data.client / data.miner etc.
    const workersObj = pick(data, ["workers","worker","clients","miners"]);

    const normalized = [];

    if (workersObj && Array.isArray(workersObj)) {
      for (let i=0;i<workersObj.length;i++){
        normalized.push(normalizeWorker(String(i+1), workersObj[i]));
      }
    } else if (workersObj && typeof workersObj === "object") {
      for (const id in workersObj){
        normalized.push(normalizeWorker(id, workersObj[id]));
      }
    }

    if (normalized.length === 0){
      // fallback: exibe alguns campos do próprio data
      const hr = pick(data, ["hashrate","hashRate","khs"]);
      const ls = pick(data, ["lastSeen","last_seen","lastSeenHuman"]);
      const up = pick(data, ["uptime","uptimeHuman","timeMining"]);
      const bd = pick(data, ["bestDifficulty","best_difficulty","bestDiff","best"]);
      els.workersWrap.innerHTML = `
        <div class="item">
          <div class="title">Resumo</div>
          <div class="cols">
            <div><div class="k">Hashrate</div><div class="v">${hr !== undefined ? fmtNum(hr)+" KH/s" : "—"}</div></div>
            <div><div class="k">Last seen</div><div class="v">${ls ?? "—"}</div></div>
            <div><div class="k">Uptime</div><div class="v">${up ?? "—"}</div></div>
            <div><div class="k">Best diff</div><div class="v">${bd ?? "—"}</div></div>
          </div>
          <div class="small" style="margin-top:8px">
            A API não retornou lista de workers/sessões nesse formato.
            Se quiser, me mande o JSON (pode ocultar partes) que eu adapto.
          </div>
        </div>
      `;
      return;
    }

    // Ordena: maior hashrate primeiro
    normalized.sort((a,b)=>(Number(b.hashrate)||0)-(Number(a.hashrate)||0));

    // Preenche cards e também os KPIs (usando o primeiro worker “mais ativo”)
    const mainW = normalized[0];
    if (mainW && mainW.hashrate !== undefined) els.hashrate.textContent = `${fmtNum(mainW.hashrate)} KH/s`;
    if (mainW && mainW.lastSeen) els.lastseen.textContent = String(mainW.lastSeen);
    if (mainW && mainW.uptime) els.uptime.textContent = String(mainW.uptime);

    for (const w of normalized){
      const item = document.createElement("div");
      item.className = "item";
      item.innerHTML = `
        <div class="title">Worker/Sessão: ${w.id}</div>
        <div class="cols">
          <div><div class="k">Hashrate</div><div class="v">${w.hashrate !== undefined ? fmtNum(w.hashrate)+" KH/s" : "—"}</div></div>
          <div><div class="k">Shares</div><div class="v">${w.shares !== undefined ? fmtNum(w.shares) : "—"}</div></div>
          <div><div class="k">Uptime</div><div class="v">${w.uptime ?? "—"}</div></div>
          <div><div class="k">Last seen</div><div class="v">${w.lastSeen ?? "—"}</div></div>
        </div>
      `;
      els.workersWrap.appendChild(item);
    }
  }

  async function refresh(){
    try{
      setStatus("warn", "Atualizando…");

      const res = await fetch(API, { cache: "no-store" });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();

      // KPIs de nível “raiz”
      const bestDiff = pick(data, ["bestDifficulty","best_difficulty","bestDiff","best"]);
      if (bestDiff !== undefined) els.bestdiff.textContent = String(bestDiff);

      // tenta preencher hashrate/lastseen/uptime pelos campos raiz caso existam
      const rootHashrate = pick(data, ["hashrate","hashRate","khs","kh_s","hashrate_khs"]);
      const rootLastSeen = pick(data, ["lastSeen","last_seen","lastSeenHuman","last_seen_human","seen","last"]);
      const rootUptime   = pick(data, ["uptime","uptimeHuman","timeMining","time_mining","sessionUptime"]);

      if (rootHashrate !== undefined) els.hashrate.textContent = `${fmtNum(rootHashrate)} KH/s`;
      if (rootLastSeen) els.lastseen.textContent = String(rootLastSeen);
      if (rootUptime) els.uptime.textContent = String(rootUptime);

      renderWorkers(data);

      // Status (online se hashrate > 0 ou lastSeen “agora”)
      const hr = Number(pick(data, ["hashrate","hashRate","khs"]) ?? 0);
      const ls = rootLastSeen ?? els.lastseen.textContent;
      if ((!Number.isNaN(hr) && hr > 0) || looksOnlineFromLastSeen(ls)) setStatus("ok", "Online (minerando)");
      else setStatus("warn", "Dados recebidos (hashrate 0?)");

    }catch(e){
      setStatus("bad", "Falha ao buscar dados");
      els.workersWrap.innerHTML = `<div class="small">Erro: ${e.message}. Se for CORS, use proxy na Hostinger.</div>`;
      els.hashrate.textContent = "—";
      els.lastseen.textContent = "—";
      els.bestdiff.textContent = "—";
      els.uptime.textContent = "—";
    }
  }

  // contador visual
  let t = 0;
  setInterval(()=>{ t = (t+1)%1000; els.tick.textContent = t; }, 1000);

  document.getElementById("refresh").addEventListener("click", ()=>{ t=0; refresh(); });

  refresh();
  setInterval(refresh, 5000);
</script>
</body>
</html>
