<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NerdMiner Dashboard v1</title>
  <style>
    :root{
      --bg:#0b1220;--card:#111b2e;--text:#e9eefc;--muted:#a9b3cf;
      --ok:#39d98a;--bad:#ff5c5c;--warn:#ffcc00;
      --btn:#1b2a47;--pill:rgba(255,255,255,.06);
      --accent:#7aa6ff;
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
    .wrap{max-width:1050px;margin:0 auto;padding:18px}
    h1{font-size:24px;margin:0 0 8px}
    .sub{color:var(--muted);font-size:13px;margin-bottom:14px;word-break:break-all}
    .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px}
    @media(min-width:860px){.grid{grid-template-columns:repeat(4,minmax(0,1fr))}}
    .card{background:var(--card);border-radius:16px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.25)}
    .k{color:var(--muted);font-size:12px}
    .v{font-size:20px;font-weight:750;margin-top:6px;word-break:break-word}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .pill{display:inline-flex;gap:8px;align-items:center;background:var(--pill);border-radius:999px;padding:7px 10px;font-size:13px}
    .dot{width:10px;height:10px;border-radius:50%}
    .ok{background:var(--ok)} .bad{background:var(--bad)} .warn{background:var(--warn)}
    .small{font-size:12px;color:var(--muted)}
    button{background:var(--btn);color:var(--text);border:0;border-radius:12px;padding:10px 12px;font-weight:600;cursor:pointer}
    button:active{transform:translateY(1px)}
    code{background:rgba(255,255,255,.08);padding:2px 6px;border-radius:8px}
    .footer{margin-top:14px;color:var(--muted);font-size:12px;line-height:1.4}
    .list{display:flex;flex-direction:column;gap:10px;margin-top:10px}
    .item{background:rgba(255,255,255,.04);border-radius:14px;padding:12px}
    .item .title{font-weight:750}
    .cols{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;margin-top:8px}
    @media(min-width:860px){.cols{grid-template-columns:repeat(4,minmax(0,1fr))}}
    .hero{border:1px solid rgba(122,166,255,.25);background:linear-gradient(180deg, rgba(122,166,255,.12), rgba(255,255,255,.02));}
    .hero .v{font-size:26px}
    .tag{display:inline-flex;align-items:center;gap:6px;margin-top:8px;color:var(--muted);font-size:12px}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>NerdMiner Dashboard</h1>
    <div class="sub">Wallet: <code id="wallet"></code></div>

    <div class="row">
      <div class="pill"><span class="dot" id="dot"></span><span id="status">Carregando…</span></div>
      <div class="pill">Atualiza: <span id="tick">—</span>s</div>
      <button id="refresh">Atualizar agora</button>
    </div>

    <!-- Destaque -->
    <div class="grid" style="margin-top:12px">
      <div class="card hero">
        <div class="k">Valid blocks</div>
        <div class="v" id="validBlocks">N/D</div>
        <div class="tag">⚠️ A API do pool (client) não fornece esse campo.</div>
      </div>

      <div class="card"><div class="k">Hashrate (atual)</div><div class="v" id="hashrate">—</div></div>
      <div class="card"><div class="k">Avg hashrate (sessão)</div><div class="v" id="avgHashrate">—</div></div>
      <div class="card"><div class="k">Tempo minerando (sessão)</div><div class="v" id="uptime">—</div></div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="card"><div class="k">Total MHashes (estimado)</div><div class="v" id="mhashes">—</div></div>
      <div class="card"><div class="k">Best difficulty</div><div class="v" id="bestdiff">—</div></div>
      <div class="card"><div class="k">Last seen</div><div class="v" id="lastseen">—</div></div>
      <div class="card"><div class="k">Sessões/Workers</div><div class="v" id="workersCount">—</div></div>
    </div>

    <div class="card" style="margin-top:12px">
      <div class="k">Workers / Sessões</div>
      <div id="workersWrap" class="list"></div>
      <div class="footer">
        “Online” aqui = last seen nos últimos <b>120s</b>. Se subir para “2 min ago”, o ESP32 caiu/perdeu Wi-Fi.
      </div>
    </div>
  </div>

<script>
  // === CONFIG ===
  const WALLET = "bc1q26ewxzrujkhz8tyazxtxdlcu4amduam6xgl78v";
  const API = `https://public-pool.io:40557/api/client/${WALLET}`;

  document.getElementById("wallet").textContent = WALLET;

  const els = {
    dot: document.getElementById("dot"),
    status: document.getElementById("status"),
    tick: document.getElementById("tick"),
    validBlocks: document.getElementById("validBlocks"),
    hashrate: document.getElementById("hashrate"),
    avgHashrate: document.getElementById("avgHashrate"),
    uptime: document.getElementById("uptime"),
    mhashes: document.getElementById("mhashes"),
    bestdiff: document.getElementById("bestdiff"),
    lastseen: document.getElementById("lastseen"),
    workersCount: document.getElementById("workersCount"),
    workersWrap: document.getElementById("workersWrap"),
  };

  function setStatus(kind, text){
    els.dot.className = "dot " + kind;
    els.status.textContent = text;
  }

  function toNum(x){
    const n = Number(x);
    return Number.isFinite(n) ? n : null;
  }

  // API retorna hashRate em H/s (string)
  function formatHashrateFromHs(hs){
    const n = toNum(hs);
    if (n === null) return "—";

    const khs = n / 1000;
    if (khs < 1000) return `${khs.toFixed(1)} KH/s`;

    const mhs = khs / 1000;
    return `${mhs.toFixed(2)} MH/s`;
  }

  function hsToKhsNumber(hs){
    const n = toNum(hs);
    if (n === null) return null;
    return n / 1000;
  }

  function msToHms(ms){
    if (!Number.isFinite(ms) || ms < 0) return "—";
    const s = Math.floor(ms/1000);
    const h = Math.floor(s/3600);
    const m = Math.floor((s%3600)/60);
    const sec = s%60;
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }

  function parseIso(iso){
    const t = Date.parse(iso);
    return Number.isFinite(t) ? t : null;
  }

  function relativeFromIso(iso){
    const t = parseIso(iso);
    if (t === null) return "—";
    const diff = Date.now() - t;
    const s = Math.floor(diff/1000);
    if (s < 0) return "—";
    if (s < 10) return "agora";
    if (s < 60) return `${s}s atrás`;
    const m = Math.floor(s/60);
    if (m < 60) return `${m} min atrás`;
    const h = Math.floor(m/60);
    return `${h} h atrás`;
  }

  function isOnline(lastSeenIso){
    const t = parseIso(lastSeenIso);
    if (t === null) return false;
    return (Date.now() - t) <= 120000; // 120s
  }

  function calcMHashes(hs, startIso){
    const nHs = toNum(hs);
    const start = parseIso(startIso);
    if (nHs === null || start === null) return null;
    const seconds = (Date.now() - start) / 1000;
    if (!Number.isFinite(seconds) || seconds < 0) return null;
    // total hashes = H/s * s ; MHashes = hashes / 1e6
    return (nHs * seconds) / 1e6;
  }

  async function refresh(){
    try{
      setStatus("warn", "Atualizando…");

      const res = await fetch(API, { cache: "no-store" });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();

      // Best difficulty (raiz)
      els.bestdiff.textContent = data.bestDifficulty ?? "—";

      // Workers count
      els.workersCount.textContent = data.workersCount ?? (Array.isArray(data.workers) ? data.workers.length : "—");

      // Valid blocks: API não entrega -> manter N/D (mas em evidência)
      els.validBlocks.textContent = "0 (N/D via API)";
      // Nota honesta: isso NÃO detecta bloco encontrado. Se quiser detecção, precisaremos de outro endpoint do pool.

      // Pega o worker principal (primeiro)
      const w = Array.isArray(data.workers) && data.workers.length ? data.workers[0] : null;

      if (!w){
        els.hashrate.textContent = "—";
        els.avgHashrate.textContent = "—";
        els.uptime.textContent = "—";
        els.mhashes.textContent = "—";
        els.lastseen.textContent = "—";
        els.workersWrap.innerHTML = `<div class="small">Nenhum worker retornado pela API.</div>`;
        setStatus("warn", "Sem workers");
        return;
      }

      // Hashrate atual
      els.hashrate.textContent = formatHashrateFromHs(w.hashRate);

      // Tempo minerando (sessão): agora - startTime
      const startMs = parseIso(w.startTime);
      const upMs = startMs ? (Date.now() - startMs) : null;
      els.uptime.textContent = upMs !== null ? msToHms(upMs) : "—";

      // Last seen
      els.lastseen.textContent = `${new Date(w.lastSeen).toLocaleString()} (${relativeFromIso(w.lastSeen)})`;

      // Total MHashes estimado
      const mh = calcMHashes(w.hashRate, w.startTime);
      els.mhashes.textContent = (mh !== null) ? mh.toLocaleString("pt-BR", { maximumFractionDigits: 2 }) : "—";

      // Avg hashrate (sessão): com apenas 1 amostra, a melhor estimativa é o hashrate atual.
      // (Para média real, precisaríamos armazenar histórico no browser ou ter API que entregue média.)
      const khs = hsToKhsNumber(w.hashRate);
      els.avgHashrate.textContent = (khs !== null) ? `${khs.toFixed(1)} KH/s` : "—";

      // Render workers list
      els.workersWrap.innerHTML = "";
      for (const ww of data.workers){
        const item = document.createElement("div");
        item.className = "item";
        item.innerHTML = `
          <div class="title">${ww.name ?? "worker"} — sessão ${ww.sessionId ?? "-"}</div>
          <div class="cols">
            <div><div class="k">Hashrate</div><div class="v">${formatHashrateFromHs(ww.hashRate)}</div></div>
            <div><div class="k">Best diff (sessão)</div><div class="v">${ww.bestDifficulty ?? "—"}</div></div>
            <div><div class="k">Start</div><div class="v">${ww.startTime ? new Date(ww.startTime).toLocaleString() : "—"}</div></div>
            <div><div class="k">Last seen</div><div class="v">${ww.lastSeen ? relativeFromIso(ww.lastSeen) : "—"}</div></div>
          </div>
        `;
        els.workersWrap.appendChild(item);
      }

      // Status online/offline
      if (isOnline(w.lastSeen)) setStatus("ok", "Online (minerando)");
      else setStatus("bad", "Offline (sem last seen recente)");

    }catch(e){
      setStatus("bad", "Falha ao buscar dados");
      els.workersWrap.innerHTML = `<div class="small">Erro: ${e.message}</div>`;
    }
  }

  // contador visual
  let t = 0;
  setInterval(()=>{ t = (t+1)%1000; els.tick.textContent = t; }, 1000);

  document.getElementById("refresh").addEventListener("click", ()=>{ t=0; refresh(); });

  refresh();
  setInterval(refresh, 5000);
</script>
</body>
</html>
